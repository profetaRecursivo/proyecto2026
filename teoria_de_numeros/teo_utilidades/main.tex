\documentclass[12pt]{article}

% Paquetes necesarios
\usepackage{amsthm}  % Para los entornos theorem, definition, etc.
\usepackage{float}
\usepackage{booktabs}
\usepackage{array}
\usepackage{amsmath}  % Para matemáticas avanzadas
\usepackage{amssymb}  % Para símbolos matemáticos
\usepackage{geometry}  % Para personalizar márgenes
\usepackage{graphicx}  % Para incluir imágenes
\usepackage{hyperref}  % Para crear hipervínculos
\usepackage{fancyhdr}  % Para encabezados personalizados
\usepackage{enumitem} % Paquete para personalizar listas

% Configuración de márgenes
\geometry{a4paper, margin=1in}

% Aumentamos la altura del encabezado para evitar el error
\setlength{\headheight}{15pt}

% Definición de los entornos theorem y definition
\newtheorem{theorem}{Teorema}[section]
\newtheorem{definition}[theorem]{Definición}
\newtheorem{example}[theorem]{Ejemplo}

% Encabezado
\pagestyle{fancy}
\fancyhead[L]{Teoría de Números}
\fancyhead[R]{\thepage}

\title{Teoría de Números}
\author{Jaime Sebastian Chavarria Fuertes}
\date{\today}

\newlist{propiedades}{itemize}{1} % Basado en itemize
\setlist[propiedades]{label=--, left=0pt, itemsep=0.5em} % Configuración personalizada

\begin{document}

\maketitle

\section{Aritmética Modular}

\subsection{Teoría de Congruencias}

Una congruencia es una relación de equivalencia entre enteros que se basa en sus restos al dividirse por un número dado.

\begin{definition}[Congruencia]
Decimos que dos números enteros \( a \) y \( b \) son congruentes módulo \( n \), y escribimos \( a \equiv b \pmod{n} \), que significa que: \[
a \% n == b \% n
\]
Tambien podemos decir que si \( a \equiv b \pmod{n} \) entonces se puede decir que:
\[ n | (a-b)\]
Es decir que \( n \) divide a: \( ( a - b ) \)
\end{definition}

\begin{example}
\( 17 \equiv 2 \pmod{5} \), ya que \( 17 - 2 = 15 \) es divisible por 5.
\end{example}
\textbf{Propiedades: }
\begin{propiedades}
    \item Si \( a \equiv b \pmod{n} \), entonces \( a + x \equiv b + x \pmod{n} \).
    \item Si \( a \equiv b \pmod{n} \), entonces \( a \cdot x \equiv b \cdot x \pmod{n} \).
    \item Si \( a \equiv b \pmod{n} \) y \( x \equiv y \pmod{n} \), entonces \( a + x \equiv b + y \pmod{n} \).
    \item \(a^{n} \equiv b^{n} \pmod{m}\)  \( \forall n \in \mathbb{N} \)
    \item Dispuesto a completar y/o agregar cosas
\end{propiedades}

\section{Fibonacci}
La secuencia tiene un monton de propiedades interesantes. Algunas de ellas son:

    \begin{theorem}[Identidad de Cassini]
        \[F_{n-1}F_{n+1} - F_n^2 = (-1)^n\]
    \end{theorem}
    \begin{theorem}[Regla de adicion]
        \[F_{n+k} = F_kF_{n+1} + F_{k-1}F_n\]
    \end{theorem}
    \begin{theorem}[Aplicando la regla previa a \(k = n\) conseguimos:]
        \[F_{2n} = F_n(F_{n+1} + F_{n-1})\]
    \end{theorem}
    \begin{theorem}
        Con la definicion anterior se puede probar que para cualquier entero positivo k, \(F_{nk}\) es multiplo de \(F_n\)
    \end{theorem}
    \begin{theorem}
        El inverso del anterior tambien es verdad, si \(F_m\) es multiplo de \(F_n\) entonces \(m\) es multiplo de \(n\)
    \end{theorem}
    \begin{theorem}[Identidad del GCD]
        \[GCD(F_m, F_n) = F_{GCD(m, n)}\]
    \end{theorem}
    \begin{itemize}
        \item Solo para saber, los numeros de Fibonacci son el peor caso en la entrada del gcd extendido
    \end{itemize}
    \subsection{Formula de Binet}
        \[F_n = \frac{(\frac{1 + \sqrt{5}}{2})^n - (\frac{1 - \sqrt{5}}{2})^n}{\sqrt{5}}\]
    Podemos deducir la formula siguiente, redondeando hacia el entero mas proximo:
        \[F_n = \frac{(\frac{1 + \sqrt{5}}{2})^n}{\sqrt{5}}\]
    Como estas dos formulas requieren alta precicion casi no tienen uso practico.
    \subsection{Calculando el F en \(O(\log n)\)}
        \[
    \begin{pmatrix} 
        1 & 1 \\ 
        1 & 0 
    \end{pmatrix}^n =
    \begin{pmatrix} 
        F_{n+1} & F_{n} \\ 
        F_{n} & F_{n-1} 
    \end{pmatrix}
    \]
    El codigo que lo implementa esta en la pagina xxx
    
    Expandiendo la matriz para \(n = 2k\)
    \[
        \begin{pmatrix}
            F_{2k+1} & F_{2k}\\
            F_{2k} & F_{2k-1}
            \end{pmatrix}
            =
            \begin{pmatrix}
            1 & 1\\
            1 & 0
            \end{pmatrix}^{2k}
            =
            \begin{pmatrix}
            F_{k+1} & F_{k}\\
            F_{k} & F_{k-1}
            \end{pmatrix}
            ^2
    \]
    Encontramos estas ecuaciones simples:
    
        \begin{align}
            F_{2k+1} &= F_{k+1}^2 + F_{k}^2 \\
            F_{2k} &= F_k(F_{k+1}+F_{k-1}) = F_k (2F_{k+1} - F_{k})
        \end{align}
    Gracias a estas ecuaciones tenemos el codigo en la pagina xx para calcular el fibonacci en tiempo logaritmico
    \subsection{Suma de \(F_0 + F_1 + ... + F_n\)}
        La suma resulta en \(F_{n+2} - 1\)
    \subsection{Es Fibonacci?}
        Un numero \(x\) pertenece a la secuencia de fibonacci si y solo si alguna (o ambas) expresiones siguientes son cuadrado(s) perfecto(s):
        \[5x^2 +4\]
        \[5x^2 - 4\]
    
\section{Funciones Aritméticas}

Las funciones aritméticas son aquellas que se definen en los números enteros y tienen aplicaciones importantes en teoría de números.

\subsection{Función \(\phi\) de Euler}
La función \(\phi(n)\) cuenta el número de enteros positivos menores o iguales que \( n \) que son coprimos con \( n \).

Dos numeros son "coprimos" cuando el \(gcd(a, b)\ = 1\)

La funcion \(phi\) hasta 21:
\begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    $n$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\
    \hline
    $\phi(n)$ & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\
    \hline
    \end{tabular}
\end{center}

\subsubsection{Propiedades}
\begin{itemize}
    \item Si \( p_1, p_2, \dots, p_k \) son los factores primos distintos de \( n \), entonces:
    \[
    \phi(n) = n \left(1 - \frac{1}{p_1}\right) \left(1 - \frac{1}{p_2}\right) \dots \left(1 - \frac{1}{p_k}\right)
    \]
    \item Si \(p\) es un numero primo, entonces el \(gcd(p, q) = 1\) para todo \(1\leq q < p\) Entonces tenemos:
        \[
            \phi (p) = p - 1.
        \]
    \item Si \(p\) es un numero primo y \(k \geq 1\) entonces hay exactamente \(\frac{p^k}{p}\) entre \(1\) y \(p^k\) que son divisibles por \(p\) Lo que nos da:
     \[\phi(p^k) = p^k - p^{k-1}.\]
    \item Si \(a\) y \(b\) son coprimos, entonces:
    \[\phi(a b) = \phi(a) \cdot \phi(b).\]
    \item De la propiedad de arriba se extiende que, si \(a\) es un número con una factorización prima:

    \[
    a = p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_k^{e_k}
    \]

    donde \(p_1, p_2, \ldots, p_k\) son primos distintos y \(e_1, e_2, \ldots, e_k\) son exponentes enteros positivos, entonces la función \(\phi(a)\) se calcula como:

    \[\phi(a) = \phi(p_1)^{e_1}\cdot \phi(p_2)^{e_2}\cdot \ldots \cdot \phi(p_k)^{e_k}\]
    Ojo, si ya tienes la criba con los primos, facil puedes precalcular la funcion phi de un numero, entonces con la factorizacion del numero en \(\O\log(n)\) podemos facil tener el resultado del la funcion \(\phi\)
    \item Esta propiedad interesante fue obtenida por Gauss:
     \[\sum_{d|n} \phi{(d)} = n\]
    Es decir la suma de todos los divisores de \(n\).
    
    Por ejemplo, los divisores de \(10\) son \(1, 2, 5, 10\). Entonces: \(\phi(1) + \phi(2) + \phi(5) +  \phi(10) = 1 + 1 + 4 + 4 = 10\)
    \item Para \(x \geq 3\) el valor de \(\phi (x)\) siempre sera par, para \(x = 1 \text{ y } x = 2\) el valor de \(\phi (x)\) es \(1\)
    \item Por consecuencia para \(x \geq 3\) el valor de \(\phi (x)\) no sera primo. \textbf{(Comprobado solo hasta \(x \leq 10^9\))} 
\end{itemize}
\subsubsection{Aplicacion}
La propiedad mas famosa e importante es expresada en \textbf{el teorema de Euler:}
\[a^{\phi(m)} \equiv 1 \pmod m \quad \text{Si } a \text{ y } m \text{ son coprimos.}\]
Cuando \(m\) es primo, el teorema de Euler se convierte en el \textbf{pequeno teorema de Fermat}
\[a^{m - 1} \equiv 1 \pmod m\]
El teorema de euler tiene aplicaciones practicas como \textbf{calcular el inverso multiplicativo modular} 

Como inmediata consecuencia de esto sabemos que:
\[a^n \equiv a^{n \bmod \phi(m)} \pmod m\]
\subsubsection{Exponenciacion \(x^y\) para un \(y\) demasaido grande}
\[x^{n}\equiv x^{\phi(m)+[n \bmod \phi(m)]} \mod m\]
\subsubsection{Teoría de Grupos}

\(\phi(n)\) es el orden del grupo multiplicativo módulo \(n\), denotado como \((\mathbb{Z} / n\mathbb{Z})^\times\). Este es el grupo de unidades (elementos con inversos multiplicativos). Los elementos con inversos multiplicativos son precisamente aquellos coprimos con \(n\).

****El orden multiplicativo de un elemento \(a\) módulo \(n\), denotado como \(\operatorname{ord}_n(a)\), es el menor entero positivo \(k > 0\) tal que:****

\[
a^k \equiv 1 \pmod{n}.
\]

\(\operatorname{ord}_n(a)\) es el tamaño del subgrupo generado por \(a\). Por el Teorema de Lagrange, el orden multiplicativo de cualquier \(a\) debe dividir a \(\phi(n)\).

Si el orden multiplicativo de \(a\) es exactamente \(\phi(n)\) (el máximo posible), entonces \(a\) es una raíz primitiva y el grupo es cíclico por definición.

\subsection{Suma y cantidad de divisores}
\subsubsection{Cantidad de divisores}
    Si la factorizacion de un numero \(n\) es \(p_1^{e_1} \cdot p_2^{e_2} \cdots p_k^{e_k}\) donde \(p_i\) son primos distintos, entonces el numero de divisores es:
        \[d(n) = (e_1 + 1) \cdot (e_2 + 1) \cdots (e_k + 1)\]
\section{Bitmasks}
    \subsection{Bitwise Identities}

    \begin{itemize}
        \item $x + y = (x \oplus y) + 2 \cdot (x \& y)$
        \item $x \oplus y = (x \mid y) - (x \& y)$
        \item $\sim x = -x - 1$ \hfill (complemento a dos)
        \item $(x \oplus y) \oplus y = x$
        \item $x \oplus x = 0$
        \item $x \& (x - 1)$ borra el bit más bajo prendido de $x$
        \item $x \& (-x)$ aísla el bit más bajo prendido
        \item $x$ es potencia de 2 $\iff x \& (x - 1) = 0$
        \item \texttt{\_\_builtin\_popcount(x)} cuenta los bits prendidos en $x$
        \item $x \% 2^k = x \& (2^k - 1)$
    \end{itemize}
    \subsection{Identidades b\'asicas:}
        \begin{itemize}
            \item $x + y = (x \oplus y) + 2 \cdot (x \& y)$
            \item $x \oplus y = (x \mid y) - (x \& y)$
            \item $\sim x = -x - 1$
            \item $(x \oplus y) \oplus y = x$
            \item $x \oplus x = 0$
            \item $x \oplus 0 = x$
        \end{itemize}
    \subsection{Propiedades de XOR}
        \begin{itemize}
            \item XOR es asociativo: $(a \oplus b) \oplus c = a \oplus (b \oplus c)$
            \item XOR es conmutativo: $a \oplus b = b \oplus a$
            \item $a \oplus a = 0$ \quad y \quad $a \oplus 0 = a$
            \item Si $a \oplus b = c$ entonces $a = b \oplus c$
        \end{itemize}
    \subsection{Bits útiles para manipulación}
        \begin{itemize}
            \item $x \& (x - 1)$: borra el bit más bajo prendido
            \item $x \& -x$: aísla el bit más bajo prendido
            \item $x \mid (x - 1)$: prende todos los bits a la derecha del más bajo prendido
            \item $x$ es potencia de dos $\iff x \& (x - 1) = 0$
            \item $x \% 2^k = x \& (2^k - 1)$
            \item $x \uparrow 1$ (o $x \ll 1$): multiplica por 2
            \item $x \downarrow 1$ (o $x \gg 1$): divide por 2 (sin signo)
        \end{itemize}
    \subsection{Conteo de bits y máscaras}
        \begin{itemize}
            \item \texttt{\_\_builtin\_popcount(x)}: número de bits prendidos
            \item \texttt{\_\_builtin\_ctz(x)}: cantidad de ceros a la derecha (trailing zeros)
            \item \texttt{\_\_builtin\_clz(x)}: cantidad de ceros a la izquierda (leading zeros)
            \item Total de subconjuntos de una máscara $x$: $2^{\texttt{popcount}(x)}$
            \item Recorrer todos los subconjuntos de $x$:
            
            \begin{verbatim}
            for (int sub = x; sub; sub = (sub - 1) & x)
                // usar sub
            \end{verbatim}
        \end{itemize}

    \subsection{Extra (interesante para DP o teoría de bits)}
    \begin{itemize}
        \item $(x \oplus y) + 2 \cdot (x \& y) = x + y$
        \item Para todo $x$, $x \oplus (x - 1)$ tiene todos los bits a la derecha del más alto en $1$
    \end{itemize}

    \section{Grafos}
        \subsection{Shortest paths}
            Un camino s \(\rightarrow\) \(\cdots\) \(\rightarrow\) u \(\rightarrow\) v es mínimo \(\iff\) 
        \[dist_u + w(u,v) = dist_v\]
    \section{Operaciones asociativas}
    \begin{table}[H]
        \centering
        \small
        \renewcommand{\arraystretch}{1.3}
        \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Operación} & \textbf{Ejemplo} & \textbf{Asociativa} & \textbf{Idempotente} \\
        \hline
        Suma $(a+b)$ & $(1+2)+3 = 1+(2+3)$ & Sí & No \\
        Producto $(a \cdot b)$ & $(2\cdot 3)\cdot 4 = 2\cdot(3\cdot 4)$ & Sí & No \\
        Resta $(a-b)$ & $(5-3)-2 \neq 5-(3-2)$ & No & No \\
        División $(a/b)$ & $(12/6)/2 \neq 12/(6/2)$ & No & No \\
        Exponenciación $(a^b)$ & $(2^3)^2 \neq 2^{(3^2)}$ & No & No \\
        Mínimo / Máximo & $\max(\max(a,b),c) = \max(a,\max(b,c))$ & Sí & Sí \\
        MCD $\gcd(a,b)$ & $\gcd(\gcd(12,18),6)=6$ & Sí & Sí \\
        MCM $\mathrm{lcm}(a,b)$ & $\mathrm{lcm}(\mathrm{lcm}(2,3),6)$ & Sí & No \\
        XOR $(a \oplus b)$ & $(a\oplus b)\oplus c = a\oplus(b\oplus c)$ & Sí & No \\
        AND bit a bit $(a \,\&\, b)$ & $(a\&b)\&c = a\&(b\&c)$ & Sí & Sí \\
        OR bit a bit $(a \mid b)$ & $(a\mid b)\mid c = a\mid(b\mid c)$ & Sí & Sí \\
        Unión de conjuntos & $(A\cup B)\cup C = A\cup(B\cup C)$ & Sí & Sí \\
        Intersección de conjuntos & $(A\cap B)\cap C = A\cap(B\cap C)$ & Sí & Sí \\
        Diferencia de conjuntos $(A-B)$ & $(A-B)-C \neq A-(B-C)$ & No & No \\
        Concatenación de strings & $(ab)c = a(bc)$ & Sí & No \\
        Promedio $\frac{a+b}{2}$ & $\frac{(a+b)}{2}$ agrupado cambia & No & No \\
        Multiplicación de matrices & $(AB)C = A(BC)$ & Sí & No \\
        \hline
        \end{tabular}
        \end{table}

\section{trailing ceros}
\[
\text{ceros}(n!) \;=\; \left\lfloor \frac{n}{5} \right\rfloor + \left\lfloor \frac{n}{5^2} \right\rfloor + \left\lfloor \frac{n}{5^3} \right\rfloor + \cdots
\]

La idea es que los ceros al final de un factorial provienen de los factores $10 = 2 \cdot 5$.
Como los números pares aportan más factores de $2$ que de $5$, el número de ceros está
determinado únicamente por la cantidad de veces que aparece el factor $5$ en la factorización de $n!$.
Por eso se suman todos los múltiplos de $5$, de $25$, de $125$, etc.

---

\[
e_p(n!) \;=\; \left\lfloor \frac{n}{p} \right\rfloor + \left\lfloor \frac{n}{p^2} \right\rfloor + \left\lfloor \frac{n}{p^3} \right\rfloor + \cdots
\]

Más generalmente, la cantidad de veces que un primo $p$ aparece en la factorización de $n!$
se obtiene sumando los múltiplos de $p$, de $p^2$, de $p^3$, y así sucesivamente.

---

\textbf{Ejemplo con un primo:}

Si $n = 100$ y $p = 2$:

\[
\left\lfloor \frac{100}{2} \right\rfloor +
\left\lfloor \frac{100}{4} \right\rfloor +
\left\lfloor \frac{100}{8} \right\rfloor +
\cdots
= 50 + 25 + 12 + 6 + 3 + 1 = 97
\]

Por lo tanto:

\[
e_2(100!) = 97
\]

es decir, el número $2$ aparece $97$ veces en la factorización prima de $100!$.

---

\textbf{Ejemplo con un número compuesto:}

Si se quiere calcular cuántas veces aparece un número compuesto $k$ en $n!$, primero se factoriza:

\[
k = p_1^{a_1} \cdot p_2^{a_2} \cdot \ldots \cdot p_m^{a_m}
\]

Luego, para cada primo $p_i$, se calcula $e_{p_i}(n!)$.  
La cantidad de veces que aparece $k$ como factor de $n!$ es:

\[
\min_i \; \left\lfloor \frac{e_{p_i}(n!)}{a_i} \right\rfloor
\]

---

\textbf{Ejemplo con $k=12$:}

\[
12 = 2^2 \cdot 3
\]

Ya sabemos que:

\[
e_2(100!) = 97, \quad e_3(100!) = 48
\]

Entonces:

\[
\left\lfloor \frac{97}{2} \right\rfloor = 48, 
\quad 
\left\lfloor \frac{48}{1} \right\rfloor = 48
\]

Por lo tanto:

\[
12^{48} \mid 100!, 
\quad 
12^{49} \nmid 100!
\]

\end{document}
