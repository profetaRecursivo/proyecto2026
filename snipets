{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"icpc": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"// #include <ext/pb_ds/assoc_container.hpp>",
			"// #include <ext/pb_ds/assoc_container.hpp>",
			"// #include <ext/pb_ds/tree_policy.hpp>",
			"// #include <ext/rope>",
			"#define int long long",
			"#define uset unordered_set",
			"#define f first",
			"#define sst stringstream",
			"#define s second",
			"#define umap unordered_map",
			"#define mp make_pair",
			"#define pb push_back",
			"#define sz(x) (int)(x).size()",
			"#define all(a) (a).begin(), (a).end()",
			"#define rall(a) (a).rbegin(), (a).rend()",
			"#define floatigual(a, b) (fabs(a - b) < EPS)",
			"#define mod(a) md(a, MOD)",
			"#define fore(i, a, n) for(int i = (a); i < (n); i++)",
			"#define forb(i, n) for (int i = (n) - 1; i >= 0; i--)",
			"#define FORDD(i, a, b) for (int i = (b) - 1; i >= (a); --i)",
			"#define techo(a, b) (a / b + (a % b != 0))",
			"#define popcount(x) __builtin_popcountll(x);",
			"using namespace std;",
			"// using namespace __gnu_pbds;",
			"// using namespace __gnu_cxx;",
			"typedef long double ld;",
			"typedef unsigned long long ull;",
			"typedef pair<int, int> pii;",
			"typedef vector<int> vi;",
			"typedef vector<bool> vbol;",
			"// typedef",
			"// tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>",
			"// ordered_set; find_by_order kth largest  order_of_key < mt19937",
			"// rng(chrono::steady_clock::now().time_since_epoch().count()); rng",
			"const int tam = 200010;",
			"const int MOD = 1000000007;",
			"const int MOD1 = 998244353;",
			"const double DINF = 1e100;",
			"const double EPS = 1e-9;",
			"const double PI = acos(-1);",
			"// Modificar la constante para la criba",
			"const int constante = 500;",
			"vector<bool> criba(constante + 1);",
			"vector<int> primos;",
			"void eratostenes() {",
			"    criba[0] = criba[1] = true;",
			"    for (int i = 2; i <= constante; ++i) {",
			"        if (!criba[i]) {",
			"            primos.push_back(i);",
			"            for (int j = i * i; j <= constante; j += i) {",
			"                criba[j] = 1;",
			"            }",
			"        }",
			"    }",
			"}",
			"int binpow(int a, int b) {",
			"    if (b == 0) {",
			"        return 1;",
			"    } else if (b == 1) {",
			"        return a;",
			"    } else if (b < 0) {",
			"        return 1 / binpow(a, -b);",
			"    } else if (b % 2 == 0) {",
			"        int we = binpow(a, b / 2);",
			"        return we * we;",
			"    } else {",
			"        return a * binpow(a, b - 1);",
			"    }",
			"}",
			"int gauss(int n) {",
			"    int res = (((n % MOD) * ((n + 1) % MOD)) % MOD) / 2;",
			"    return res;",
			"}",
			"int expMod(int base, int exponente, int mod) {",
			"    int res = 1;",
			"    base %= mod;",
			"    while (exponente > 0) {",
			"        if (exponente % 2 == 1) res = (res * base) % mod;",
			"        exponente >>= 1;",
			"        base = (base * base) % mod;",
			"    }",
			"    return res;",
			"}",
			"class UnionFind {",
			"    vector<int> parents;",
			"    vector<int> sizes;",
			" ",
			"   public:",
			"    UnionFind(int size) : parents(size), sizes(size, 1) {",
			"        for (int i = 0; i < size; i++) {",
			"            parents[i] = i;",
			"        }",
			"    }",
			"    int find(int x) {",
			"        return parents[x] == x ? x : (parents[x] = find(parents[x]));",
			"    }",
			"    bool join(int x, int y) {",
			"        int x_root = find(x);",
			"        int y_root = find(y);",
			"        if (x_root == y_root) {",
			"            return false;",
			"        }",
			"        if (sizes[x_root] < sizes[y_root]) {",
			"            swap(x_root, y_root);",
			"        }",
			"        sizes[x_root] += sizes[y_root];",
			"        parents[y_root] = x_root;",
			"        return true;",
			"    }",
			"    bool connected(int x, int y) { return find(x) == find(y); }",
			"};",
			"",
			"void solve() {",
			"    ",
			"}",
			"signed main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"    cout.tie(0);",
			"    int t = 1;",
			"    cin>>t;//comment this",
			"    while(t--)solve();",
			"}",
			"//PLUS ULTRA RECARGADO!!!"
		],
		"description": "Plantilla para problemas de programacion competitiva, tu puedes! :)"
	},
	"icpc_minimo": {
		"prefix": "algoritmos",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define int long long",
			"#define f first",
			"#define sst stringstream",
			"#define s second",
			"#define pb push_back",
			"#define sz(x) (int)(x).size()",
			"#define all(a) (a).begin(), (a).end()",
			"#define rall(a) (a).rbegin(), (a).rend()",
			"#define fore(i, a, n) for(int i = (a); i < (n); i++)",
			"#define forb(i, n) for (int i = (n) - 1; i >= 0; i--)",
			"#define popcount(x) __builtin_popcountll(x);",
			"typedef long double ld;",
			"typedef pair<int, int> pii;",
			"typedef vector<int> vi;",
			"const int MOD = 1000000007;",
			"const double EPS = 1e-9;",
			"const double PI = acos(-1);",
			"const int INF = 1e18;",
			"//PLUS ULTRA RECARGADO!!!",
			"void solve() {",
			"    ",
			"}",
			"signed main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"    cout.tie(0);",
			"    int t = 1;",
			"    cin>>t;",
			"    while(t--)solve();",
			"}"
		],
		"description": "Nos vamos a coger a ese examen de algoritmos!"
	},
	"point_int": {
		"prefix": "_intpt",
		"body": [
			"struct point_i {",
			"    // Construccion",
			"    int x, y;",
			"    point_i() : x(0), y(0) {}",
			"    point_i(int x, int y) : x(x), y(y) {}",
			"    // Operadores",
			"    point_i operator-() { return point_i(-x, -y); }",
			"    point_i operator+(point_i p) { return point_i(x + p.x, y + p.y); }",
			"    point_i operator-(point_i p) { return point_i(x - p.x, y - p.y); }",
			"    point_i operator*(int k) { return point_i(k * x, k * y); }",
			"    // producto punto",
			"    int operator*(point_i p) { return x * p.x + y * p.y; }",
			"    // producto cruz",
			"    int operator%(point_i p) { return x * p.y - y * p.x; }",
			"    // Comparadores",
			"    bool operator==(const point_i &p) const { return x == p.x and y == p.y; }",
			"    bool operator!=(const point_i &p) const { return x != p.x or y != p.y; }",
			"    bool operator<(const point_i &p) const {",
			"        return (x < p.x) or (x == p.x and y < p.y);",
			"    }",
			"    bool dentro(point_i &a, point_i &b) {",
			"        return min(a.x, b.x) <= (*this).x and (*this).x <= max(a.x, b.x) and",
			"               min(a.y, b.y) <= (*this).y and (*this).y <= max(a.y, b.y);",
			"    }",
			"",
			"    // Longitudes y distancias",
			"    ld abs() { return sqrtl(x * x + y * y); }",
			"    int abs2() { return x * x + y * y; }",
			"    ld dist(point_i q) { return (*this - q).abs(); }",
			"    int dist2(point_i q) { return (*this - q).abs2(); }",
			"    // Angulo respecto al eje x (1,1) -> 45 (pero en radianes)",
			"    ld arg() { return atan2l(y, x); } ",
			"};",
			"",
			"// Rotacion horaria y antihoraria",
			"point_i rotate_ccw90(point_i p) {",
			"    return point_i(-p.y, p.x);",
			"}",
			"point_i rotate_cw90(point_i p) {",
			"    return point_i(p.y, -p.x);",
			"}",
			"",
			"int area_2(point_i a, point_i b, point_i c) {",
			"    return (a%b) + (b%c) + (c%a);",
			"}",
			"ostream &operator<<(ostream &os, const point_i &p) {",
			"    os << \"(\" << p.x << \",\" << p.y << \")\";",
			"    return os;",
			"}",
			"istream &operator>>(istream &in, point_i &p) {",
			"   in >> p.x >> p.y;",
			"   return in;",
			"}"
		],
		"description": "100 en geometia cabron"
	},
	"point_double": {
		"prefix": "_ldpt",
		"body": [
			"#include <bits/stdc++.h>",
			"typedef long double ld;",
			"using namespace std;",
			"ld EPS = 1e-9, PI = acos(-1.);",
			"",
			"// Funciones de comparaci贸n con precisi贸n",
			"bool ge(ld x, ld y) {",
			"    return x + EPS > y;",
			"}",
			"bool le(ld x, ld y) {",
			"    return x - EPS < y;",
			"}",
			"bool eq(ld x, ld y) {",
			"    return ge(x, y) and le(x, y);",
			"}",
			"",
			"bool gt(ld x, ld y) {",
			"    return ge(x, y) and !eq(x, y);",
			"}",
			"bool lt(ld x, ld y) {",
			"    return le(x, y) and !eq(x, y);",
			"}",
			"",
			"int sign(ld x) {",
			"    return ge(x, 0) - le(x, 0);",
			"}",
			"",
			"struct point {",
			"    ld x, y;",
			"    point() : x(0), y(0) {}",
			"    point(ld _x, ld _y) : x(_x), y(_y) {}",
			"",
			"    point operator-() { return point(-x, -y); }",
			"    point operator+(point p) { return point(x + p.x, y + p.y); }",
			"    point operator-(point p) { return point(x - p.x, y - p.y); }",
			"",
			"    point operator*(ld k) { return point(k * x, k * y); }",
			"    point operator/(ld k) { return point(x / k, y / k); }",
			"",
			"    // inner product",
			"    ld operator*(point p) { return x * p.x + y * p.y; }",
			"    // cross product",
			"    ld operator%(point p) { return x * p.y - y * p.x; }",
			"",
			"    // Funciones de comparaci贸n con precisi贸n para los puntos",
			"    bool operator<(point &p2) {",
			"        return lt(x, p2.x) or (eq(x, p2.x) and lt(y, p2.y));",
			"    }  // menor que",
			"    bool operator>(point &p2) {",
			"        return gt(x, p2.x) or (eq(x, p2.x) and gt(y, p2.y));",
			"    }  // mayor que",
			"    bool operator<=(point &p2) {",
			"        return le(x, p2.x) or (eq(x, p2.x) and le(y, p2.y));",
			"    }  // menor o igual",
			"    bool operator>=(point &p2) {",
			"        return ge(x, p2.x) or (eq(x, p2.x) and ge(y, p2.y));",
			"    }  // mayor o igual",
			"",
			"    // 0 => same direction",
			"    // 1 => p is on the left",
			"    //-1 => p is on the right",
			"    int dir(point o, point p) {",
			"        ld x = (*this - o) % (p - o);",
			"        return ge(x, 0) - le(x, 0);",
			"    }",
			"",
			"    bool on_seg(point p, point q) {",
			"        if (this->dir(p, q)) return 0;",
			"        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and",
			"               ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));",
			"    }",
			"",
			"    ld abs() { return sqrt(x * x + y * y); }",
			"    ld abs2() { return x * x + y * y; }",
			"    ld dist(point q) { return (*this - q).abs(); }",
			"    ld dist2(point q) { return (*this - q).abs2(); }",
			"",
			"    ld arg() { return atan2l(y, x); }",
			"",
			"    point project(point y) { return y * ((*this * y) / (y * y)); }",
			"    point project(point x, point y) { return x + (*this - x).project(y - x); }",
			"",
			"    ld dist_line(point x, point y) { return dist(project(x, y)); }",
			"    ld dist_seg(point x, point y) {",
			"        return project(x, y).on_seg(x, y) ? dist_line(x, y)",
			"                                          : min(dist(x), dist(y));",
			"    }",
			"",
			"    point rotate(ld sin, ld cos) {",
			"        return point(cos * x - sin * y, sin * x + cos * y);",
			"    }",
			"    point rotate(ld a) { return rotate(sinl(a), cosl(a)); }",
			"    point rotate(point p) { return rotate(p.y / p.abs(), p.x / p.abs()); }",
			"};",
			"",
			"int direction(point o, point p, point q) {",
			"    return p.dir(o, q);",
			"}",
			"",
			"point rotate_ccw90(point p) {",
			"    return point(-p.y, p.x);",
			"}",
			"point rotate_cw90(point p) {",
			"    return point(p.y, -p.x);",
			"}",
			"// double area",
			"ld area_2(point a, point b, point c) {",
			"    return (a % b) + (b % c) + (c % a);",
			"}",
			"",
			"int angle_less(point &a1, point &b1, point &a2, point &b2) {",
			"    // angle between (a1 and b1) vs angle between (a2 and b2)",
			"    // 1  : bigger",
			"    //-1 : smaller",
			"    // 0  : equal",
			"    point p1(a1 * b1, abs(a1 % b1));",
			"    point p2((a2 * b2), abs(a2 % b2));",
			"    if (p1 % p2 < 0) return 1;",
			"    if (p1 % p2 > 0) return -1;",
			"    return 0;",
			"}",
			"",
			"ostream &operator<<(ostream &os, point &p) {",
			"    os << \"(\" << p.x << \",\" << p.y << \")\";",
			"    return os;",
			"}",
			"istream &operator>>(istream &in, point &p) {",
			"    in >> p.x >> p.y;",
			"    return in;",
			"}",
			""
		],
		"description": "de verdad que nos cogemos a ese examen"
	},
	"fraccion": {
		"prefix": "__frac",
		"body": [
			"struct frac {",
			"int num, den;",
			"frac() : num(0), den(1) {}",
			"frac(int a, int b) {",
			"        int g = gcd(abs(a), abs(b));",
			"        num = a / g;",
			"        den = b / g;",
			"                if (den < 0) {",
			"                        num = -num;",
			"                        den = -den;",
			"                }",
			"        }",
			"",
			"        frac operator+(const frac& other) const {",
			"                int nuevo_num = num * other.den + den * other.num;",
			"                int nuevo_den = den * other.den;",
			"                return frac(nuevo_num, nuevo_den);",
			"        }",
			"",
			"        frac operator-(const frac& other) const {",
			"                int nuevo_num = num * other.den - den * other.num;",
			"                int nuevo_den = den * other.den;",
			"                return frac(nuevo_num, nuevo_den);",
			"        }",
			"",
			"        frac operator*(const frac& other) const {",
			"                int nuevo_num = num * other.num;",
			"                int nuevo_den = den * other.den;",
			"                return frac(nuevo_num, nuevo_den);",
			"        }",
			"",
			"        frac operator/(const frac& other) const {",
			"                int nuevo_num = num * other.den;",
			"                int nuevo_den = den * other.num;",
			"                return frac(nuevo_num, nuevo_den);",
			"        }",
			"",
			"        friend ostream& operator<<(ostream& os, const frac& f) {",
			"                os << f.num;",
			"                if (f.den != 1) { os << \"/\" << f.den; }",
			"                return os;",
			"        }",
			"",
			"        int piso() { return num / den; }",
			"        int techo() { return (num / den + (num % den == 0 ? 0 : 1)); }",
			"        long double exacto() {",
			"                long double a = num;",
			"                long double b = den;",
			"                return a / b;",
			"         }",
			"",
			"    private:",
			"         int ___gcd(int a, int b) const { return b == 0 ? a : gcd(b, a % b); }",
			"};",
		]
	},
	"hull": {
		"prefix": "_hull",
		"body": [
			"int orientation(point a, point b, point c) {",
			"    double v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);",
			"    if (v < 0) return -1; // clockwise",
			"    if (v > 0) return +1; // counter-clockwise",
			"    return 0;",
			"}",
			"",
			"bool cw(point a, point b, point c, bool include_collinear) {",
			"    int o = orientation(a, b, c);",
			"    return o < 0 || (include_collinear && o == 0);",
			"}",
			"bool ccw(point a, point b, point c, bool include_collinear) {",
			"    int o = orientation(a, b, c);",
			"    return o > 0 || (include_collinear && o == 0);",
			"}",
			"",
			"void convex_hull(vector<point>& a, bool include_collinear = false) {",
			"    if (a.size() == 1)",
			"        return;",
			"",
			"    sort(a.begin(), a.end(), [](point a, point b) {",
			"        return make_pair(a.x, a.y) < make_pair(b.x, b.y);",
			"    });",
			"    point p1 = a[0], p2 = a.back();",
			"    vector<point> up, down;",
			"    up.push_back(p1);",
			"    down.push_back(p1);",
			"    for (int i = 1; i < (int)a.size(); i++) {",
			"        if (i == a.size() - 1 || cw(p1, a[i], p2, include_collinear)) {",
			"            while (up.size() >= 2 && !cw(up[up.size()-2], up[up.size()-1], a[i], include_collinear))",
			"                up.pop_back();",
			"            up.push_back(a[i]);",
			"        }",
			"        if (i == a.size() - 1 || ccw(p1, a[i], p2, include_collinear)) {",
			"            while (down.size() >= 2 && !ccw(down[down.size()-2], down[down.size()-1], a[i], include_collinear))",
			"                down.pop_back();",
			"            down.push_back(a[i]);",
			"        }",
			"    }",
			"",
			"    if (include_collinear && up.size() == a.size()) {",
			"        reverse(a.begin(), a.end());",
			"        return;",
			"    }",
			"    a.clear();",
			"    for (int i = 0; i < (int)up.size(); i++)",
			"        a.push_back(up[i]);",
			"    for (int i = down.size() - 2; i > 0; i--)",
			"        a.push_back(down[i]);",
			"}"
		],
		"description": "hoy hagamos la excepcion"
	},
	"_ccwsort": {
		"prefix": "_ccwsort",
		"body": [
			"void sort_ccw(vector<point_i>& points) {",
			"    point_i pivot = *min_element(points.begin(), points.end());",
			"",
			"    sort(points.begin(), points.end(), [&pivot](point_i& a,  point_i& b) {",
			"        auto vecA = a - pivot;",
			"        auto vecB = b - pivot;",
			"        int cross = vecA % vecB;",
			"",
			"        if (cross == 0) ",
			"            return (vecA.x * vecA.x + vecA.y * vecA.y) < (vecB.x * vecB.x + vecB.y * vecB.y);",
			"        ",
			"        return cross > 0; ",
			"    });",
			"}",
		],
		"description": "que pasa causa"
	},
	"__binpow": {
		"prefix": "__binpow",
		"body": [
			"int binpow(int a, int b) {",
			"    int res = 1;",
			"    while (b > 0) {",
			"        if (b & 1)",
			"            res = res * a;",
			"        a = a * a;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "exponenciacion binaria"
	},
	"__expmod": {
		"prefix": "__expmod",
		"body": [
			"int expmod(int a, int b, int m) {",
			"    a %= m;",
			"    int res = 1;",
			"    while (b > 0) {",
			"        if (b & 1)",
			"            res = res * a % m;",
			"        a = a * a % m;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "binpow modular"
	},
	"__mulmod": {
		"prefix": "__mulmod",
		"body": [
			"int mulmod(int a, int b, int m) {",
			"    int ans = 0; ",
			"    while (a > 0) {",
			"        if (a&1) {",
			"            ans = (ans + b) % m;",
			"        }",
			"        b = (b<<1) % m;",
			"        a>>=1;",
			"    }",
			"    return ans; ",
			"}",
		],
		"description": "multiplicacion modular para evitar desbordes"
	}
}